\section{Methods}
\label{sec:methods_chip}

\subsection{Data description}
The populations comprising the set of haplotypes from which tag \glspl{SNP} for the hypothetical \gls{SNP} array is selected are distributed across the continent (figure \ref{fig}. They represent 3 novel populations and 2 populations from phase 1 of \gls{1000G}.
\input{fig/afr5pop.png}

\subsection{Selection of tag SNPs and identification of informative variants for a hypothetical SNP array}
\input{fig/imp_accu_allele}

For identification of informative variants on the chip array we utilised a hybrid algorithm with cycles of \gls{LD} based pairwise tagging, and imputation, as previously described.\cite{Hoffmann2011422}

We have developed a multi-population tagging algorithm based on the algorithm TAGster for \gls{WGS} data.\cite{Xu2007} The methods we used for tagging were identical to those used by TAGster; however, by using seeking and indexing approaches we were able to optimise the computational efficiency of the algorithm by an order of magnitude (unpublished data, Carstensen et al.). We briefly outline the tagging algorithm as follows (\ref{fig:SN13f1}):

\begin{enumerate}
\item Calculate \gls{LD} (\textit{r}\textsuperscript{2}) between each \gls{SNP} and all other \glspl{SNP} in the flanking 250kbp region for each population separately. \gls{MAF} thresholds are imposed at this stage, and only pairs of \glspl{SNP} where both exceed the \gls{MAF} threshold are included.
\item For each \gls{SNP} not already in the tagging set, a count of \glspl{SNP} in the target set that are in \gls{LD} exceeding a given threshold \textit{r}\textsuperscript{2} with it is generated across the genome and summed across all populations.
\item The most informative \gls{SNP} (the \gls{SNP} with most target \glspl{SNP} in \gls{LD} with it summed across population) is chosen as the tagging \gls{SNP} and added to the set of tagging \glspl{SNP}. If two \glspl{SNP} have the same ranking, then a \gls{SNP} is chosen by one or all of the following parameters in order of preference: 1) presence on existing SNP arrays (count), 2) presence in 1000G and/or dbSNP (binary), 3) location within a gene region (binary), 4) binned genotyping score provided by the vendor, 5) rate of heterozygosity across all populations (continuous).
%We do not take the vicinity to existing tag SNPs into account, despite  SNPs in close proximity being able to interfere with each other when assayed.\cite{21535878} We expect the algorithm to avoid this problem, because SNPs in proximity of each other are also likely to be in LD with each other.
\item This tagging SNP and SNPs in LD with it are now removed from the set of target SNPs. This process is carried out separately for each population, so that a separate set of target SNPs is maintained for each population set. However, SNPs in LD with the tagging SNP can still be picked up as tagging SNPs themselves if they independently tag the maximum no. of SNPs in any iteration.
Steps 2-3 are repeated until either a specified number of SNPs or all target SNPs (chosen as SNPs above a specific MAF threshold per-population) are tagged across all population sets, or until a specific number of SNPs is reached, as specified.
\end{enumerate}

Although this method works well across populations, it only carries out pairwise single-marker tagging. Haplotype based, or multi-marker tagging would potentially be more efficient, and select fewer tagging sites. In order to incorporate haplotype based tagging into our model, we use a hybrid method, with cycles of tagging and imputation, as has been described before.\cite{Hoffmann2011422}

\input{fig/SN13f1}

We implement this method by selecting a maximum number of pre-defined tagging \glspl{SNP} in the first cycle. With these tagging \glspl{SNP} we simulate a chip for each population, and imputation is carried out using a reference panel, to identify additional sites in each population that are tagged at an \gls{r2} threshold above 0.80 by the tagging sites. These sites are removed from the target set for each population, and do not contribute to the next cycle, thereby making the process more efficient. To maximise imputation accuracy we use all samples in table \ref{tab:samples} for the reference panel and merge this reference panel with haplotypes from all of the \gls{1000G} samples from Europe, Asia and the Americas not already present in the reference panel. However, for imputation into each population, all samples from the given population are removed from the reference panel. This ‘leave one population out’ approach would produce relatively conservative results for tagging, with more variants being tagged than if a subsample of the population was included in the reference panel. This is a more realistic scenario, as it is not necessary that any given population genotyped on the chip in future would be represented in the reference panel.

Additionally, pre-selected known biologically relevant variants, valuable to the studies planned for consortia can be included on the array, to replace certain tag \glspl{SNP}. We have previously shown that a 1M tagging variants chosen using the described algorithm can produce greater than 0.80 coverage across diverse populations in Africa. Based on this, we plan to carry out approximately 10 cycles to capture 1.2M tagging variants, in order to prioritise variants to include in the design of a 1M chip array. Following this, we will further validate our tagging algorithm among populations with smaller sample sizes that were not included in the development in the chip array, by selecting tagging variants among these and imputing with the reference panel, excluding these populations. We estimate coverage of each population by such a chip array using imputation. Coverage is defined as the proportion of common variation captured at a correlation greater than 0.80 across the genome in a given population with the combined reference panel (excluding the population being evaluated). $r^{2}$, here, is calculated as the correlation between the sequence data and imputed data on a hypothetical 1M chip array for common variation. 

%Instead of random choice do 1) chip overlap, 2) quality score (VQSLOD and MVNcall posterior), 3) white/black list

\subsection{Computational description of calculation of pairwise \gls{LD} values}
Haplotype files are block gzipped\cite{Li05012011}, which allows them to be indexed. This allows for rapid calculation of pairwise \gls{LD} between \glspl{SNP} in a window of a certain size with a small amount of memory usage. I calculated the LD with Python3\footnote{https://github.com/team149/tc9/blob/master/ragtagger/calculateLD.py}. The pairwise \gls{LD} values can also be estimated from non-phased genotypes by using the \gls{EM} algorithm.
%https://github.com/team149/tc9/blob/master/WGS/QC/vcf2pca.py
Alternatively the pairwise \gls{LD} values can now be calculated with PLINK1.9\cite{25722852}. These pairwise LD values are then used as input for the tag SNP selection program RagTagger\footnote{https://github.com/team149/tc9/blob/master/ragtagger/ragtagger.py}.

\subsection{Computational description of selection of tag \glspl{SNP} from pairwise \gls{LD} values
The selection of tag \glspl{SNP} between imputation cycles after calculation of pairwise \gls{LD} values is carried out with RagTagger\footnote{https://github.com/team149/tc9/blob/master/ragtagger/ragtagger.py}, which is a memory and \gls{CPU} efficient rewrite of the software TAGster.\cite{Xu2007} For the work presented here it was set up to be able to parse sets of pre-selected SNPs and SNPs not to be used as tag SNPs. To avoid keeping all the \gls{LD} information in memory the number and identity of tagged SNPs was then calculated from the \gls{LD} files and written to a block gzipped\cite{LI05012011} file, which was indexed on the fly, which allows subsequent random access. Only the \gls{LD} count and the random access position for each potential tag SNP was kept in memory in hash tables to allow O(1) look ups. The dictionary with SNP IDs as keys and LD counts as values is inverted and these SNPs are looped through from most common to least common until exhaused or the upper limit for tag SNPs (overall or for the cycle) is reached.